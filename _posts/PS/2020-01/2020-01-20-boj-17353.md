---
title: ë°±ì¤€ 17353 í•˜ëŠ˜ì—ì„œ ë–¨ì–´ì§€ëŠ” 1, 2, ..., R-L+1ê°œì˜ ë³„ í’€ì´
# ì˜¤ë²„ë ˆì´ ë˜ëŠ” ì´ë¯¸ì§€ ë° ê¸€
excerpt: í•˜ëŠ˜ì—ì„œ ë–¨ì–´ì§€ëŠ” 1ì–µê°œì˜ ë³„

classes: wide

#toc: true
#toc_label: "ëª©ì°¨"
#toc_icon: "cog" # ë‚´ ì»¨í…ì¸ ì— ëŒ€í•œ ëª©ì°¨ë¥¼ ì˜¤ë¥¸ìª½ì— ë„ì›Œì¤Œ

#last_modified_at: 2019-12-08T00:00:00+09:00 # ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ë‚ ì§œë¥¼ ë³´ì—¬ì¤Œ

tags: [ProblemSolving, segmenttree]
categories: [PS,]
---

# ë¬¸ì œ
```
https://www.acmicpc.net/problem/17353

&Title
17353ë²ˆ - í•˜ëŠ˜ì—ì„œ ë–¨ì–´ì§€ëŠ” 1, 2, ..., R-L+1ê°œì˜ ë³„

&Question
ìš±ì œì˜ ì€ë°€í•œ ì·¨ë¯¸ ì¤‘ í•˜ë‚˜ëŠ” ë§¤ì¼ ë°¤í•˜ëŠ˜ì„ ê°ìƒí•˜ëŠ” 
ê²ƒì´ë‹¤. ğŸ˜“ ìš±ì œëŠ” í•˜ëŠ˜ì˜ ë³„ë“¤ì´ ë‹¤ìŒê³¼ ê°™ì€ ê·œì¹™ë“¤ì„ ë”°ë¥´ë©° 
ë–¨ì–´ì§€ëŠ” ê±¸ ê´€ì°°í–ˆë‹¤.ë³„ì´ ë–¨ì–´ì§€ëŠ” ìœ„ì¹˜ëŠ” Nê°œì˜ ì ì´ë‹¤. ì ì€ ìˆœì„œëŒ€ë¡œ 
1, 2, ..., Nì˜ ë²ˆí˜¸ë¥¼ ê°–ëŠ”ë‹¤.ë§¤ì¼ ë°¤ ë³„ë“¤ì€ 1, 
2, ..., Nì˜ ì—°ì†í•œ ë¶€ë¶„ êµ¬ê°„ [L, R]ì— ë–¨ì–´ì§„ë‹¤.[L, 
R]ì— ë³„ì´ ë–¨ì–´ì§€ë©´, ê° ì ì—ëŠ” ìˆœì„œëŒ€ë¡œ 1, 2, ..., 
R-L+1ê°œì˜ ë³„ì´ ë–¨ì–´ì§„ë‹¤. ë‹¤ì‹œ ë§í•´, Lì—ëŠ” 1ê°œ, L+1ì—ëŠ” 2ê°œ, 
..., Rì—ëŠ” R-L+1ê°œì˜ ë³„ì´ ë–¨ì–´ì§„ë‹¤.ìš±ì œëŠ” í•˜ëŠ˜ì—ì„œ ë–¨ì–´ì§€ëŠ” ë³„ë“¤ì„ ê¸°ë¡í•˜ë‹¤ê°€ 
ì ì´ ë“¤ì–´ë²„ë ¸ë‹¤!! í˜¹ì‹œë‚˜ í–ˆì§€ë§Œ ì—­ì‹œë‚˜, ì—¬ëŸ¬ë¶„ì€ ìš±ì œë¥¼ ëŒ€ì‹ í•´ ì•„ë˜ì˜ 
ì¿¼ë¦¬ë¥¼ ìˆ˜í–‰í•´ì•¼ í•œë‹¤. (ã…ã…;; ã…ˆã…….. ã…‹ã…‹!!)1 L R: [L, 
R]ì— ë³„ì´ ë–¨ì–´ì§„ë‹¤. (1 â‰¤ L â‰¤ R â‰¤ 
N)2 X: ì  Xì— ë–¨ì–´ì§„ ë³„ì˜ ê°œìˆ˜ì˜ í•©ì„ ì¶œë ¥í•œë‹¤. 
(1 â‰¤ X â‰¤ N) 

&Input
ì²«ì§¸ ì¤„ì— ë³„ì´ ë–¨ì–´ì§€ëŠ” ì ì˜ ê°œìˆ˜ Nì´ ì£¼ì–´ì§„ë‹¤. 
(1 â‰¤ N â‰¤ 105)ë‘˜ì§¸ ì¤„ì— ìš±ì œê°€ ì ë“¤ê¸° ì „ê¹Œì§€ 
ì„¸ì–´ ë†“ì€, ì´ë¯¸ ë–¨ì–´ì§„ ë³„ë“¤ì˜ ê°œìˆ˜ A1, ..., ANì´ 
ê³µë°±ì„ ì‚¬ì´ì— ë‘ê³  ì£¼ì–´ì§„ë‹¤. (0 â‰¤ A1, ..., AN 
â‰¤ 106)ì…‹ì§¸ ì¤„ì—ëŠ” ì¿¼ë¦¬ì˜ ê°œìˆ˜ Qê°€ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ 
Q â‰¤ 105)ë„·ì§¸ ì¤„ë¶€í„° Qê°œì˜ ì¤„ì—ëŠ” ì¿¼ë¦¬ê°€ í•œ ì¤„ì— 
í•˜ë‚˜ì”© ì£¼ì–´ì§„ë‹¤. 

&Output
2ë²ˆ ì¿¼ë¦¬ì— ëŒ€í•œ ë‹µì„ í•œ ì¤„ì— í•˜ë‚˜ì”© ì¶œë ¥í•œë‹¤. 


&Example
-input
5
1 2 1 2 1
4
1 1 5
2 5
1 2 5
2 5

-output
6
10
```

# ìš”ì•½
* ìš±ì œëŠ” ë°¤í•˜ëŠ˜ì˜ ë³„ì„ ìƒˆë‹¤ê°€ ì ë“¤ì–´ ë²„ë ¸ë‹¤. ìš±ì œ ëŒ€ì‹  ì¿¼ë¦¬ë¥¼ ì²˜ë¦¬í•˜ì—¬ ë³„ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ì.
* 1 L R: [L, R]ì— ë³„ì´ ë–¨ì–´ì§„ë‹¤. (1 â‰¤ L â‰¤ R â‰¤ N)
* 2 X: ì  Xì— ë–¨ì–´ì§„ ë³„ì˜ ê°œìˆ˜ì˜ í•©ì„ ì¶œë ¥í•œë‹¤. (1 â‰¤ X â‰¤ N)
* L, R ì‚¬ì´ì˜ ë–¨ì–´ì§€ëŠ” ë³„ì€ 1, 2, ..., R-L+1ê°œê°€ ê°ê° ë–¨ì–´ì§„ë‹¤.

# ì ‘ê·¼
* ë§¤ë²ˆ ì „ì²´ ì—…ë°ì´íŠ¸í•˜ë©´ ì‹œê°„ ì´ˆê³¼ ë‚ ê±° ê°™ìœ¼ë‹ˆê¹ ì„¸ê·¸ë¨¼íŠ¸íŠ¸ë¦¬ lazy propagationì„ ì´ìš©í•˜ì—¬ ì—…ë°ì´íŠ¸ í•´ì¤€ë‹¤.

# í’€ì´
1. ë¨¼ì € ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë¥¼ ë³´ì í•´ë‹¹ êµ¬ê°„ì¸ ê²½ìš° start - left + 1ì˜ ê°’ì„ ë”í•´ì£¼ê³ , ê°¯ìˆ˜ë¥¼ ì¦ê°€ì‹œì¼œì¤€ë‹¤. ì¦‰ 3~5êµ¬ê°„ì„ ì—…ë°ì´íŠ¸ í• ë•Œ, 3, 4~5ì— ëŒ€í•´ì„œ ì €ëŸ° ì‹ì„ ì—…ë°ì´íŠ¸ í•´ì£¼ëŠ” ê²ƒì´ë‹¤. start - left + 1ì´ ì˜ë¯¸í•˜ëŠ” ê²ƒì€ 3ì¸ê²½ìš°ëŠ” start - left = 0ì´ë¼ ìƒê´€ì—†ì§€ë§Œ, 4~5ì¸ê²½ìš°ëŠ” start - leftê°€ 1ì´ë‹¤. ì¦‰ í•´ë‹¹ ë²”ìœ„ì— ëŒ€í•œ ìµœì†Œ ìˆ«ìë¥¼ ì—…ë°ì´íŠ¸ë¥¼ í•´ì£¼ê³ , ë‚˜ë¨¸ì§€ 4, 5ì— ëŒ€í•œ ì²˜ë¦¬ëŠ” cnt++ì„ í†µí•´ queryí• ë•Œ ì—°ì‚°í•˜ê²Œë” í•˜ëŠ”ê±°ë‹¤.
    ```
    void update(int index, int left, int right, int start, int end) {
        if (left > end || right < start)
            return;

        if (left <= start && end <= right) {
            tree[index].val += start - left + 1;
            tree[index].cnt++;
        }
        else {
            int mid = (start + end) / 2;
            update(index * 2, left, right, start, mid);
            update(index * 2 + 1, left, right, mid + 1, end);
        }
    }
    ```
1. ë¦¬í”„ë…¸ë“œì¸ ê²½ìš°ëŠ” ì´ë¯¸ ì•ì— start - left + 1ì‹ì—ì„œ ë”í•´ì§ˆ ë§Œí¼ ë”í•´ì¡Œê¸° ë•Œë¬¸ì— ê°’ë§Œ ë„˜ê²¨ì¤€ë‹¤. ì´ì œ ì–‘ìª½ ì¿¼ë¦¬ë¥¼ ë”í•´ì£¼ëŠ”ë°, `tree[index].val + tree[index].cnt * (target - start)` ì´ ë¶€ë¶„ì´ í•µì‹¬ì´ ë˜ì‹œê² ë‹¤. í•´ë‹¹ ìˆ«ìì˜ cnt*(target - start)ë¥¼ ë”í•´ì£¼ì–´ ê²°êµ­ `target - left + 1`ì˜ ê°’ì„ ë”í•œê±°ë‚˜ ë‹¤ë¦„ì—†ê¸° ì¿¼ë¦¬ë¥¼ í•˜ê²Œ ëœë‹¤.
    ```
    long long query(int index, int target, int start, int end) {
        if (target < start || target > end)
            return 0;
        
        if (start == end) {
            return tree[index].val;
        }
        else {
            int mid = (start + end) / 2;
            return query(index * 2, target, start, mid) +
                query(index * 2 + 1, target, mid + 1, end) +
                tree[index].val + tree[index].cnt * (target - start);
        }
    }
    ```

# í‹€ë ¸ë˜ ì´ìœ 
* L, R ì‚¬ì´ì˜ ë–¨ì–´ì§€ëŠ” ë³„ì´ R-L+1ì´ë¼ê³  ë³´ê³  ê°œê½ë¬¸ì œë„¤? í•˜ê³  ì‹ ë‚˜ê²Œ í’€ë‹¤ê°€ í‹€ë ¸ë‹¤... ì©

# ì†ŒìŠ¤
{% highlight c++ %}
#include <iostream>
using namespace std;

const int MAXN = 1e5;
struct info {
	long long val, cnt;
};
int n, m;
long long node[MAXN + 1];
info tree[MAXN * 4];

void init(int index, int start, int end) {
	if (start == end) {
		tree[index].val = node[start];
	}
	else {
		int mid = (start + end) / 2;
		init(index * 2, start, mid);
		init(index * 2 + 1, mid + 1, end);
	}
}

void update(int index, int left, int right, int start, int end) {
	if (left > end || right < start)
		return;

	if (left <= start && end <= right) {
		tree[index].val += start - left + 1;
		tree[index].cnt++;
	}
	else {
		int mid = (start + end) / 2;
		update(index * 2, left, right, start, mid);
		update(index * 2 + 1, left, right, mid + 1, end);
	}
}

long long query(int index, int target, int start, int end) {
	if (target < start || target > end)
		return 0;
	
	if (start == end) {
		return tree[index].val;
	}
	else {
		int mid = (start + end) / 2;
		return query(index * 2, target, start, mid) +
			query(index * 2 + 1, target, mid + 1, end) +
			tree[index].val + tree[index].cnt * (target - start);
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> node[i];
	init(1, 1, n);
	cin >> m;
	int a, b, c;
	while (m--) {
		cin >> a >> b;
		if (a == 1) {
			cin >> c;
			update(1, b, c, 1, n);
		}
		else {
			cout << query(1, b, 1, n) << '\n';
		}
	}
	return 0;
}
{% endhighlight %}